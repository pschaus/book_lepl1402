

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Algorithms and Data Structures &#8212; LEPL1402  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parallel Programming" href="part5.html" />
    <link rel="prev" title="Unit testing" href="part3.html" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-125847974-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="part5.html" title="Parallel Programming"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="part3.html" title="Unit testing"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LEPL1402  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms and Data Structures</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="algorithms-and-data-structures">
<span id="part4"></span><h1>Algorithms and Data Structures<a class="headerlink" href="#algorithms-and-data-structures" title="Permalink to this heading">¶</a></h1>
<section id="time-complexity">
<h2>Time Complexity<a class="headerlink" href="#time-complexity" title="Permalink to this heading">¶</a></h2>
<p>In the rapidly evolving world of computer science, the efficiency of an algorithm is paramount.
As we strive to tackle increasingly complex problems and manage growing volumes of data,
understanding how our algorithms perform becomes more important than ever.</p>
<p>This is where the concept of <em>time complexity</em> comes into play.</p>
<p>Time complexity provides a theoretical estimation of the time an algorithm requires to run relative to the size of the input data.
In other words, it allows us to predict the efficiency of our code before we even run it.
It’s like having a magic crystal ball that tells us how our algorithm will behave in the wild!</p>
<p>Let’s delve into the intricacies of time complexity and uncover the beauty and elegance of efficient code by studying first a very simple <code class="docutils literal notranslate"><span class="pre">sum()</span></code> method that calculates the total sum of all the elements in an integer array provided as argument.</p>
<div class="highlight-java notranslate" id="sum"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">total</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One can measure the time it takes using <code class="docutils literal notranslate"><span class="pre">System.currentTimeMillis()</span></code> method
that returns the current time in milliseconds since the Unix Epoch (January 1, 1970 00:00:00 UTC).
It is typically used to get a timestamp representing the current point in time.
Here is an example of how to use it to measure the time of one call to the <code class="docutils literal notranslate"><span class="pre">sum()</span></code> method.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">startTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">totalSum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">endTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">duration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">endTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startTime</span><span class="p">);</span><span class="w">  </span><span class="c1">// duration in milliseconds</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, if one makes vary the size of values one can observe the evolution of execution time
in function of the size of the input array given in argument to <code class="docutils literal notranslate"><span class="pre">sum()</span></code> and plot it.
Here is what we obtain on a standard laptop.</p>
<figure class="align-default" id="id8">
<a class="reference internal image-reference" href="_images/sum_complexity.png"><img alt="Sum time" src="_images/sum_complexity.png" style="width: 595.0px; height: 299.5px;" /></a>
<figcaption>
<p><span class="caption-text">Evolution of time measures taken by <cite>sum</cite> on arrays of increasing size.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Undoubtedly, the absolute time is heavily reliant on the specifications of the machine the code is executed on. The same code running on a different laptop could produce different timing results. However, it is noteworthy that the time evolution appears to be linear with respect to the array size, as illustrated by the trend line.</p>
<p>A crucial question arises: could this have been foreseen without even running the code? The answer is affirmative! <span id="id1">Hartmanis and Stearns [<a class="reference internal" href="index.html#id3" title="Juris Hartmanis and Richard E Stearns. On the computational complexity of algorithms. Transactions of the American Mathematical Society, 117:285–306, 1965.">HS65</a>]</span> laid down the foundations for such theoretical analyses from the source-code without (or pseudo-code, as the algorithm itself is of greater significance), even without requiring running the code and measure time.
This great invention is explained next, but first things first, we need a simple computation model.</p>
<section id="the-random-access-machine-ram-model-of-computation">
<h3>The Random Access Machine (RAM) model of computation<a class="headerlink" href="#the-random-access-machine-ram-model-of-computation" title="Permalink to this heading">¶</a></h3>
<p>The RAM, or Random Access Machine, model of computation is a theoretical model of a computer that provides a mathematical abstraction for algorithm analysis.
In the RAM model, each “simple” operation (such as addition, subtraction, multiplication, division, comparison, bitwise operations, following a reference, or direct addressing of memory) can be done in a single unit of time.
It assumes that memory accesses (like accessing an element in an array: <code class="docutils literal notranslate"><span class="pre">value[i]</span></code> above) take constant time, regardless of the memory location.
This is where the name “random access” comes from, since any memory location can be accessed in the same amount of time.</p>
<p>This abstraction is quite realistic for many practical purposes, and closely models real computers (a bit like Newton laws is a good approximation of general relativity).</p>
<p>Of course we can’t assume a loop is a “simple” operation in the RAM model.
One need to count the number of times its body will be executed.
The next code add comments on the number of steps required to execute the sum algorithm.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">         </span><span class="c1">// n = values.length</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                             </span><span class="c1">// 1 step</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">                    </span><span class="c1">// 2* n steps (one memory access and one addition executed n times)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">total</span><span class="p">;</span><span class="w">                              </span><span class="c1">// 1 step</span>
<span class="p">}</span><span class="w">                                              </span><span class="c1">// TOTAL: 2n + 2 steps</span>
</pre></div>
</div>
<p>In practice, it is difficult to translate one step into a concrete time since it depends on many factors (machine, language, compiler, etc.).
It is also not true that every operation takes exactly the same amount of time.
Remember that it is just an approximation.
We’ll further simplify our step-counting approach by utilizing classes of functions that easily interpretable for practitioners like us.</p>
<p>Let us first realize in the next section that even for a consistent input size, the execution time of an algorithm can vary significantly.</p>
</section>
<section id="best-case-and-worst-case-scenarios-of-an-algorithm">
<h3>Best-case and worst-case scenarios of an algorithm<a class="headerlink" href="#best-case-and-worst-case-scenarios-of-an-algorithm" title="Permalink to this heading">¶</a></h3>
<p>Different inputs of the same size may cause an algorithm to take more or fewer steps to arrive at a result.</p>
<p>To illustrate this, consider the <code class="docutils literal notranslate"><span class="pre">linearSearch()</span></code> method that looks whether an array contains a specific target value and that returns the first index having this value, or <code class="docutils literal notranslate"><span class="pre">-1</span></code> if this value is not present in the array.</p>
<div class="highlight-java notranslate" id="linear-search"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This method performs a linear search on an array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param arr The input array.</span>
<span class="cm"> * @param x   The target value to search for in the array.</span>
<span class="cm"> * @return The index of the target value in the array if found,</span>
<span class="cm"> *          or -1 if the target value is not in the array.</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">linearSearch</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method achieves its goal by iterating through the array and returning the index of the first occurrence of the target value. If the target value isn’t present, it returns <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>In this case, the number of steps the <code class="docutils literal notranslate"><span class="pre">linearSearch()</span></code> method takes to complete is heavily dependent on the position of the target value within the array. If the target value is near the beginning of the array, the <code class="docutils literal notranslate"><span class="pre">linearSearch()</span></code> method completes quickly.
We call this the <em>best-case scenario</em>.</p>
<p>Conversely, if the target value is at the end of the array or not present at all, the method must iterate through the entire array, which naturally takes more steps.
We call this, the <em>worst-case scenario</em>.</p>
<p>The execution of <code class="docutils literal notranslate"><span class="pre">linearSearch()</span></code> can thus greatly vary depending not only on the <em>size</em> of the input array, but also on the <em>content</em> of the input array. Other categories of algorithms will have a execution that is mostly determined by the input size, rather than the input content.
This characteristic is exemplified by the <code class="docutils literal notranslate"><span class="pre">sum()</span></code> method we previously analyzed.</p>
<p>The notation we are about to introduce for characterizing the execution time of an algorithm will allow us to represent both the best and worst-case scenarios.</p>
</section>
<section id="the-big-o-big-omega-and-big-theta-classes-of-functions">
<h3>The Big-O, Big-Omega and Big-Theta classes of functions<a class="headerlink" href="#the-big-o-big-omega-and-big-theta-classes-of-functions" title="Permalink to this heading">¶</a></h3>
<p>Let us assume that the number of steps an algorithm requires can be represented by the function <img class="math" src="_images/math/64f9e9cfb9d05136a6870761ae94a54f71d4f83d.svg" alt="T(n)"/> where <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> refers to the size of the input, such as the number of elements in an array. While this function might encapsulate intricate details about the algorithm’s execution, calculating it with high precision can be a substantial undertaking, and often, not worth the effort.</p>
<p>For sufficiently large inputs, the influence of multiplicative constants and lower-order terms within the exact runtime is overshadowed by the impact of the input size itself. This leads us to the concept of asymptotic efficiency, which is particularly concerned with how an algorithm’s running time escalates with an increase in input size, especially as the size of the input grows unboundedly.</p>
<p>Typically, an algorithm that is asymptotically more efficient will be the superior choice for all but the smallest of inputs.
This section introduces standard methods and notations used to simplify the asymptotic analysis of algorithms, thereby making this complex task more manageable.
We shall see asymptotic notations that are well suited to characterizing running times no matter what the input.</p>
<p>Those so-called Big-Oh notations are sets or classes of functions.
We have classes of function asymptotically bounded by above, below or both:</p>
<ul class="simple">
<li><p><img class="math" src="_images/math/d89d66c572e51b874c318e07f8f34615110de2f9.svg" alt="f(n)\in \mathcal{O}(g(n)) \Longleftrightarrow"/> <img class="math" src="_images/math/da7482ab812d8c32d866f5b14bf27483935ff587.svg" alt="\exists c \in \mathbb{R}^+,n_0 \in \mathbb{N}: f(n) \leq c\cdot g(n)\ \forall n \geq n_0"/> (upper bound)</p></li>
<li><p><img class="math" src="_images/math/913624177fa3dfd3537bc16c883d253f44ee6caa.svg" alt="f(n)\in \Omega(g(n)) \Longleftrightarrow"/> <img class="math" src="_images/math/f74c8a1b2796bd23c65e53b5c7dd8c5d82cc0dc2.svg" alt="\exists c \in \mathbb{R}^+,n_0 \in \mathbb{N}: f(n) \geq c\cdot g(n)\ \forall n \geq n_0"/> (lower bound)</p></li>
<li><p><img class="math" src="_images/math/b7c3882077dd3aaa7546992c94a194e64da6555a.svg" alt="f(n)\in \Theta(g(n)) \Longleftrightarrow"/><img class="math" src="_images/math/4c7d9c88e4ec0187be2785fbdeba656a0d3a3396.svg" alt="\exists c_1, c_2 \in \mathbb{R}^+,n_0 \in \mathbb{N}: c_1\cdot g(n) \leq f(n) \leq c_2\cdot g(n)\ \forall n \geq n_0"/> (exact bound)</p></li>
</ul>
<p>What is common in the definitions of these classes of function is that we are not concerned about small constant.
Instead we care about the big-picture that is when <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> becomes really large (say 10,000 or 1,000,000). The intuition for those classes of function notations are illustrated next.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/bigo.png"><img alt="bigo" src="_images/bigo.png" style="width: 456.0px; height: 275.0px;" /></a>
</figure>
<p>One big advantage of Big-Oh notations is the capacity to simplify  notations by only keeping the fastest growing term and taking out the numerical coefficients.
Let us consider an example of simplification: <img class="math" src="_images/math/1f40d25df4bd5b644ec954fb2e78b7afecd04942.svg" alt="f(n)=c \cdot n^a + d\cdot n^b\quad"/> with <img class="math" src="_images/math/bacd54451985de59da8344edf5746a965cea6c4c.svg" alt="a \geq b \geq 0"/> and <img class="math" src="_images/math/b8945dea6d6b6bd08a517aefa56282a6a297efce.svg" alt="c, d \geq 0"/>.
Then we have <img class="math" src="_images/math/0e6eb2bc556d2c5b4d2bb2013038d60a3315d090.svg" alt="f(n) \in \Theta(n^a)"/>.
This is even true if <img class="math" src="_images/math/d520a12f1579170834c32ad5f656de081bbb36fe.svg" alt="c"/> is very small and <img class="math" src="_images/math/badad346f6fbe2e237af99bfbd9a93a4da53a3da.svg" alt="d"/> very big!</p>
<p>The simplification principle that we have applied are the following:
<img class="math" src="_images/math/d3e4e80b7ef7c81c09804a9c16a9048d8fa63194.svg" alt="\mathcal{O}(c \cdot f(n)) = \mathcal{O}(f(n))"/> (for <img class="math" src="_images/math/4e96e2c0d43ddc6cc5283e10a3211bae0c28418a.svg" alt="c&gt;0"/>) and <img class="math" src="_images/math/8e3149cd6a5259634a8d0ad34f7bea854b9076a1.svg" alt="\mathcal{O}(f(n) + g(n)) \subseteq \mathcal{O}(\max(f(n), g(n))))"/>.
You can also use these inclusion relations to simplify:
<img class="math" src="_images/math/a0024ec7eaac25ef834a3fe43da2004c0273960a.svg" alt="\mathcal{O}(1) \subseteq \mathcal{O}(\log n) \subseteq \mathcal{O}(n) \subseteq \mathcal{O}(n^2) \subseteq \mathcal{O}(n^3) \subseteq \mathcal{O}(c^n) \subseteq \mathcal{O}(n!)"/></p>
<p>As a general rule of thumb, when speaking about the time complexity of an algorithm using Big-Oh notations, you must simplify if possible to get rid of numerical coefficients.</p>
<p id="recursivity">..Recursive Algorithms
.. ———————-</p>
</section>
<section id="practical-examples-of-different-algorithms">
<h3>Practical examples of different algorithms<a class="headerlink" href="#practical-examples-of-different-algorithms" title="Permalink to this heading">¶</a></h3>
<p>To grasp a theoretical concept such as time complexity and Big O notation, concrete examples are invaluable.
For each of the common complexities, we present an algorithmic example and then break down the reasons behind its specific time complexity.
The following table provides an overview of the most prevalent complexity classes, accompanied by algorithm examples we explain after.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Complexity (name)</p></th>
<th class="head"><p>Algorithm</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><img class="math" src="_images/math/383f07bf3c51d10543fd52d61077438d888b4308.svg" alt="\mathcal{O}(1)"/> (constant)</p></td>
<td><p>Sum of two integers</p></td>
</tr>
<tr class="row-odd"><td><p><img class="math" src="_images/math/1906c24994bd3a59c1328c2163793c21e06c6b99.svg" alt="\mathcal{O}(\log n)"/> (logarithmic)</p></td>
<td><p>Find an entry in a sorted array (binary search)</p></td>
</tr>
<tr class="row-even"><td><p><img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/> (linear)</p></td>
<td><p>Sum elements or find an entry in a not sorted array</p></td>
</tr>
<tr class="row-odd"><td><p><img class="math" src="_images/math/d7c851d1765c6ac8aaa28c943087e6a8b4b3e85f.svg" alt="\mathcal{O}(n \log n)"/> (linearithmic)</p></td>
<td><p>Sorting efficiently an array (merge sort)</p></td>
</tr>
<tr class="row-even"><td><p><img class="math" src="_images/math/0d46836ff354f180306676ded9ebb233e0b01f5b.svg" alt="\mathcal{O}(n^2)"/> (quadratic)</p></td>
<td><p>Sorting inefficiently an array (insertion sort)</p></td>
</tr>
<tr class="row-odd"><td><p><img class="math" src="_images/math/cbe7f1bf4cfffe31e0c2c8dd79afba3b5a481789.svg" alt="\mathcal{O}(n^3)"/> (cubic)</p></td>
<td><p>Enumerating all possible triples taken from an array</p></td>
</tr>
<tr class="row-even"><td><p><img class="math" src="_images/math/32214f476fdbd3424a8c1b522620d370dcba788b.svg" alt="\mathcal{O}(2^n)"/> (exponential)</p></td>
<td><p>Finding elements in an array summing to zero (Subset-sum)</p></td>
</tr>
<tr class="row-odd"><td><p><img class="math" src="_images/math/75b374adf4c4c55a4ea77cd468581017ff8a2193.svg" alt="\mathcal{O}(n!)"/> (factorial)</p></td>
<td><p>Visiting all cities in a country by minimizing the distance</p></td>
</tr>
</tbody>
</table>
<section id="binary-search">
<h4>Binary Search<a class="headerlink" href="#binary-search" title="Permalink to this heading">¶</a></h4>
<p>The Binary search, also known as dichotomic search, is a search algorithm that finds the position of a target value within a sorted array.
It works by halving the number of elements to be searched each time, which makes it incredibly efficient even for large arrays.</p>
<p>Here’s how the binary search algorithm works:</p>
<ol class="arabic simple">
<li><p>You start with the middle element of the sorted array.</p></li>
<li><p>If the target value is equal to this middle element, then you’ve found the target and the algorithm ends.</p></li>
<li><p>If the target value is less than the middle element, then you repeat the search with the left half of the array.</p></li>
<li><p>If the target value is greater than the middle element, then you repeat the search with the right half of the array.</p></li>
<li><p>You keep repeating this process until you either find the target value or exhaust all elements.</p></li>
</ol>
<p>The execution of this search is illustrated on next schema searching for value 7 repeating 4 times the process until finding it.
On this array of 16 entries, the search will never require more than four trials, so this is the worst-case scenario.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/binary_search.png"><img alt="binarysearch" src="_images/binary_search.png" style="width: 720.0px; height: 306.5px;" /></a>
</figure>
<p>This algorithm has a time complexity of <img class="math" src="_images/math/1906c24994bd3a59c1328c2163793c21e06c6b99.svg" alt="\mathcal{O}(\log n)"/> because each time we go through the loop, the number of elements to be searched is halved and in the worst case, this process is repeated <img class="math" src="_images/math/33c7abf8c20ad3622194e6b6a557f13d7e80581b.svg" alt="\log n"/> times.
On the other hand, if we are lucky, the search immediately find the element at the first iteration.
Therefore the best-case time complexity is <img class="math" src="_images/math/e74baf4036ece30d1ed3d0089b773c41c3fbd9db.svg" alt="\Omega(1)"/>.</p>
<p>The Java code is a direct translation of the explanation of the algorithm.</p>
<div class="highlight-java notranslate" id="id2"><div class="highlight"><pre><span></span><span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * This method performs a binary search on a sorted array.</span>
<span class="cm">     * The array remains unchanged during the execution of the function.</span>
<span class="cm">     *</span>
<span class="cm">     * @param arr The input array, which must be sorted in ascending order.</span>
<span class="cm">     * @param x   The target value to search for in the array.</span>
<span class="cm">     * @return The index of the target value in the array if found,</span>
<span class="cm"> *          or -1 if the target value is not in the array.</span>
<span class="cm">     */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">binarySearch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Check if x is present at mid</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If x greater, ignore left half</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If x is smaller, ignore right half</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If we reach here, then element was not present</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Notice that the expression <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">+</span> <span class="pre">(right</span> <span class="pre">-</span> <span class="pre">left)</span> <span class="pre">/</span> <span class="pre">2</span></code> is preferred over the somewhat simpler <code class="docutils literal notranslate"><span class="pre">(left</span> <span class="pre">+</span> <span class="pre">right)</span> <span class="pre">/</span> <span class="pre">2</span></code> to calculate the middle index in a binary search. At first glance, they seem to do the same thing, and indeed, they usually do give the same result.
The main advantage of using <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">+</span> <span class="pre">(right</span> <span class="pre">-</span> <span class="pre">left)</span> <span class="pre">/</span> <span class="pre">2</span></code> over <code class="docutils literal notranslate"><span class="pre">(left</span> <span class="pre">+</span> <span class="pre">right)</span> <span class="pre">/</span> <span class="pre">2</span></code> comes into play when you are dealing with large numbers.
The problem with <code class="docutils literal notranslate"><span class="pre">(left</span> <span class="pre">+</span> <span class="pre">right)</span> <span class="pre">/</span> <span class="pre">2</span></code> is that the sum of <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> could exceed the maximum limit of the integer in the Java language that is is <img class="math" src="_images/math/5603129c3ac8c5fcd7fec379ef3af5682a7b33ff.svg" alt="2^{31}-1"/>, causing an integer overflow, which can lead to unexpected results or errors.
The one used <code class="docutils literal notranslate"><span class="pre">left</span> <span class="pre">+</span> <span class="pre">(right</span> <span class="pre">-</span> <span class="pre">left)</span> <span class="pre">/</span> <span class="pre">2</span></code> does not have this overflow risk problem.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Keep in mind that when dealing with objects (as opposed to primitive types), we would want to use the <code class="docutils literal notranslate"><span class="pre">equals()</span></code> method instead of <code class="docutils literal notranslate"><span class="pre">==</span></code>.
This is because <code class="docutils literal notranslate"><span class="pre">equals()</span></code> tests for logical equality, meaning it checks whether two objects are logically equivalent (even if they are different instances). On the other hand, <code class="docutils literal notranslate"><span class="pre">==</span></code> tests for reference equality, which checks whether two references point to the exact same object instance. For objects where logical equality is more meaningful than reference equality, like <code class="docutils literal notranslate"><span class="pre">String</span></code> or custom objects, using <code class="docutils literal notranslate"><span class="pre">equals()</span></code> is the appropriate choice.</p>
</div>
</section>
<section id="id3">
<h4>Linear Search<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>We already have seen the <span class="xref std std-ref">sum</span> algorithm and its <img class="math" src="_images/math/529a0c57cd2fea8b0566dea7a79f2dd436bc280b.svg" alt="\Theta(n)"/> time complexity.
Another example of a linear time complexity algorithm is the <span class="xref std std-ref">linear_search</span>.
The time complexity of the linear search algorithm is <img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/>, where <cite>n</cite> is the size of the array, because in the worst-case scenario (the target value is not in the array or is the last element in the array), the algorithm has to examine every element in the array once.
In the best-case scenario for the linear search algorithm, the target value is the very first element of the array.
Therefore, in the best-case scenario, the time complexity of the linear search algorithm is <img class="math" src="_images/math/383f07bf3c51d10543fd52d61077438d888b4308.svg" alt="\mathcal{O}(1)"/> or we can simply say that the algorithm is also in <img class="math" src="_images/math/579fc76f571273a31acaeb895c4e9f62cd593208.svg" alt="\Omega (1)"/>.</p>
</section>
<section id="merge-sort">
<h4>Merge Sort<a class="headerlink" href="#merge-sort" title="Permalink to this heading">¶</a></h4>
<p>Merge sort is a <em>divide-and-conquer</em> algorithm for sorting lists or arrays of items using pair-wise comparisons.
It works by dividing the unsorted list into <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> sublists, each containing one element (a list of one element is considered sorted), and then repeatedly merging sublists to produce newly sorted sublists until there is only one sublist remaining.</p>
<p>Here’s the basic idea behind merge sort:</p>
<ul class="simple">
<li><p>Divide: If the list is of length 0 or 1, then it is already sorted. Otherwise, divide the unsorted list into two sublists of about half the size.</p></li>
<li><p>Conquer: Sort each sublist recursively by re-applying the merge sort.</p></li>
<li><p>Combine: Merge the two sublists back into one sorted list.</p></li>
</ul>
<p>Here is a simple implementation of Merge Sort in Java:</p>
<div class="highlight-java notranslate" id="merge-sort-implem"><div class="highlight"><pre><span></span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="o">[]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">leftIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">rightIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">leftIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">rightIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rightIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="p">(</span><span class="n">leftIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">]</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="o">[</span><span class="n">leftIndex</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">leftIndex</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="o">[</span><span class="n">rightIndex</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">rightIndex</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Sort the values increasingly</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// list of size 1, already sorted</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="n">mid</span><span class="o">]</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// copy values[0..mid-1] to left</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// copy values[mid..values.length-1] to right</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="n">mid</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// sort left and right</span>
<span class="w">    </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// merge left and right back into values</span>
<span class="w">    </span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Merge sort is a divide and conquer algorithm.
It breaks the array into two subarrays, sort them, and then merges these sorted subarrays to produce a final sorted array.
All the operations and the data-flow of execution is best understood with a small visual example.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/merge_sort_complexity.png"><img alt="Sum time" src="_images/merge_sort_complexity.png" style="width: 595.5px; height: 341.0px;" /></a>
</figure>
<p>There are <img class="math" src="_images/math/b5c4010ba81caeee74b220a097e6b5a0432343eb.svg" alt="\Theta(\log n)"/> layers of split and merge operations.
Each layer requires <img class="math" src="_images/math/529a0c57cd2fea8b0566dea7a79f2dd436bc280b.svg" alt="\Theta(n)"/> operations by summing all the split/merge operations at one level.
In the end, the time complexity of the merge sort algorithm is the product of the time complexities of these two operations that is <img class="math" src="_images/math/52d9a2e529559fa5c81be6b458a139be50700de7.svg" alt="\Theta(n \log n)"/>.</p>
</section>
<section id="insertion-sort">
<h4>Insertion Sort<a class="headerlink" href="#insertion-sort" title="Permalink to this heading">¶</a></h4>
<p>The insertion sort algorithm is probably the one you use when sorting a hand of playing cards.
You start with one card in your hand (the sorted portion).
For each new card, you insert it in the correct position in your hand by moving over any cards that should come after it.</p>
<p>The Java code is given next.</p>
<div class="highlight-java notranslate" id="id4"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This method sort the array using Insertion Sort algorithm.</span>
<span class="cm"> *</span>
<span class="cm"> * @param arr The input array.</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">insertionSort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Move elements of arr[0..i-1], that are greater than key,</span>
<span class="w">        </span><span class="c1">// to one position ahead of their current position</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For each element (except the first), it finds the appropriate position among the already sorted elements (all elements before the current one), and inserts it there by moving larger elements up.
Moving the larger elements up is the goal of the inner <code class="docutils literal notranslate"><span class="pre">while</span></code> loop.</p>
<p>The time complexity of insertion sort is <img class="math" src="_images/math/0d46836ff354f180306676ded9ebb233e0b01f5b.svg" alt="\mathcal{O}(n^2)"/> in the worst-case scenario, because each of the <code class="docutils literal notranslate"><span class="pre">n</span></code> elements could potentially need to be compared with each of the <code class="docutils literal notranslate"><span class="pre">n</span></code> already sorted elements.
However, in the best-case scenario (when the input array is already sorted), the time complexity is <img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/>, because each element only needs to be compared once with the already sorted elements.
Alternatively, we can simply say that the insertion sort algorithm runs in <img class="math" src="_images/math/1387d7d1fc6c969067d16054961483811769db71.svg" alt="\Omega(n)"/> and <img class="math" src="_images/math/0d46836ff354f180306676ded9ebb233e0b01f5b.svg" alt="\mathcal{O}(n^2)"/>.</p>
</section>
<section id="triple-sum">
<h4>Triple Sum<a class="headerlink" href="#triple-sum" title="Permalink to this heading">¶</a></h4>
<p>We consider a algorithm that checks if there exists at least one combination of three elements in an array that sum up to zero.
Here an implementation in Java:</p>
<div class="highlight-java notranslate" id="id5"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This method checks if there are any three numbers in the array that sum up to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @param arr The input array.</span>
<span class="cm"> * @return True if such a triple exists, false otherwise.</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">checkTripleSum</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this program, <code class="docutils literal notranslate"><span class="pre">checkTripleSum()</span></code> goes through each possible combination of three elements in the input array.
If it finds a triple that sums up to zero, it immediately returns <code class="docutils literal notranslate"><span class="pre">true</span></code>. If no such triple is found after checking all combinations, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. Since there are <img class="math" src="_images/math/36bde959423d2281df479ee69abb1740db81de2b.svg" alt="n*(n-1)*(n-2)/6"/> possible combinations of three elements in an array of length <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/>, and we’re checking each combination once, the time complexity of this method is <img class="math" src="_images/math/cbe7f1bf4cfffe31e0c2c8dd79afba3b5a481789.svg" alt="\mathcal{O}(n^3)"/> and <img class="math" src="_images/math/e74baf4036ece30d1ed3d0089b773c41c3fbd9db.svg" alt="\Omega(1)"/>.
The best-case scenario occurs if the first three elements in the array sum to zero so that each loop is in its first iteration when the <code class="docutils literal notranslate"><span class="pre">return</span></code> instruction occurs.</p>
</section>
<section id="subset-sum">
<h4>Subset-Sum<a class="headerlink" href="#subset-sum" title="Permalink to this heading">¶</a></h4>
<p>The subset-sum problem is a classic problem in computer science: Given a set of integers, is there a subset of the integers that sums to zero?
This is a generalization of the <code class="docutils literal notranslate"><span class="pre">checkTripleSum()</span></code> problem we have seen before, in which the allowed subsets must not contain exactly 3 elements.</p>
<p>The algorithm we will use for solving the problem is a <em>brute-force</em> approach that will enumerate all the possible subsets.
A common approach to enumerate all the subsets is to use recursion.
We can consider each number in the set and make a recursive call for two cases: one where we exclude the number in the subset, and one where we include it.</p>
<p>The Java code is given next. It calls an auxiliary method with an additional argument <code class="docutils literal notranslate"><span class="pre">sum()</span></code> that is the sum of the elements
up to index <code class="docutils literal notranslate"><span class="pre">i</span></code> already included.</p>
<div class="highlight-java notranslate" id="id6"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This method checks if there is a subset of the array that sums up to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * @param arr   The input array.</span>
<span class="cm"> * @return True if there is such a subset, false otherwise.</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isSubsetSumZero</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">isSubsetSum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isSubsetSum</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Base cases</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// did not find it</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// found it</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Check if sum can be obtained by excluding / including the next</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">isSubsetSum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">                   </span><span class="n">isSubsetSum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The time complexity of this algorithm is <img class="math" src="_images/math/32214f476fdbd3424a8c1b522620d370dcba788b.svg" alt="\mathcal{O}(2^n)"/>, because in the worst case it generates all possible subsets of the array, and there are <img class="math" src="_images/math/d76f16a00dc1dd4eb18ca913e933b14079c81f2b.svg" alt="2^n"/> possible subsets for an array of n elements. The worst case is obtained when there is no solution and that <code class="docutils literal notranslate"><span class="pre">false</span></code> is returned.
The best-case complexity is <img class="math" src="_images/math/e74baf4036ece30d1ed3d0089b773c41c3fbd9db.svg" alt="\Omega(1)"/> and is obtained when the first element in the array is zero so that the algorithm immediately returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Note that this algorithm has an exponential time complexity (so far the algorithm we have studied were polynomial e.g., <img class="math" src="_images/math/cbe7f1bf4cfffe31e0c2c8dd79afba3b5a481789.svg" alt="\mathcal{O}(n^3)"/>). Therefore, although this approach will work fine for small arrays, it will be unbearably slow for larger ones.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The question that arises is: Can we find an efficient algorithm to solve this problem more efficiently? By “efficient”, we mean an algorithm that doesn’t take an exponential time to compute as the size of the input grows.
The answer is, maybe but we don’t know yet.
Researchers stumbled upon a category of problems discovered in the early 1970’s, that share a common trait: They all seem to be impossible to solve efficiently, but if you’re handed a potential solution, you can at least verify its correctness quickly.
The subset-sum problem belongs to this class.
This category is called <em>NP</em> (Nondeterministic Polynomial time).</p>
<p>Now, within NP, there’s a special class of problems dubbed <em>NP-complete</em>.
What is so special about them? Well, if you can find an efficient solution for one <em>NP-complete</em> problem, you’ve essentially found efficient solutions for all of them!
The subset-sum problem is one of these NP-complete problems. Like its NP-complete siblings, we don’t have efficient solutions for it yet.
But remember, this doesn’t mean that no efficient solution exists; we just haven’t found one and it was also not yet proven that such an algorithm does not exist.
This also doesn’t mean that there are no faster algorithms for the subset-sum problem that the one we have shown.
For instance a <em>dynamic programming</em> algorithm (out of scope of this introduction to algorithms) for subset-sum can avoid redundant work, but still has a worst-case exponential time complexity.</p>
</div>
</section>
<section id="visiting-all-cities-in-a-country-minimizing-the-distance">
<h4>Visiting all cities in a country minimizing the distance<a class="headerlink" href="#visiting-all-cities-in-a-country-minimizing-the-distance" title="Permalink to this heading">¶</a></h4>
<p>The Traveling Salesman Problem (TSP) is a classic NP-hard problem in the field of computer science and operations research. The problem is simple to state: Given a list of cities and the distances between them, find the shortest possible route that visits each city exactly once and returns to the starting city.</p>
<p>This problem, as well as its decision version (i.e., does there exist a circuit with a total length shorter than a given value?), is proven to be NP-complete.
We suggest a straightforward brute-force approach to address this challenge. This method involves enumerating all possible permutations of the cities and maintaining a record of the permutation that yields the shortest distance.
The time complexity of this strategy is <img class="math" src="_images/math/50fa78eb190aa6d504a236ace5f17cb25cee79d0.svg" alt="O(n!)"/> (factorial) because it necessitates generating all the permutations and computing the total length for each one.</p>
<p>When the number of cities exceeds 12, the brute-force method becomes increasingly impractical.
Even with high-speed modern computers, attempting to solve the TSP for, say, 20 cities using brute-force would involve evaluating
<img class="math" src="_images/math/60dde6a568328926e53823c8ad15ea65b1f67a17.svg" alt="20! \sim 2.43 * 10^{18}"/> routes—a task that would take many years.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In contrast, more sophisticated algorithms have been developed for the TSP.
Techniques such as branch and bound can effectively solve TSP instances with thousands of cities, making them vastly more scalable than the brute-force approach.</p>
</div>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TSPBruteForce</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">},</span>
<span class="w">                </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">},</span>
<span class="w">                </span><span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">35</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">},</span>
<span class="w">                </span><span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">Result</span><span class="w"> </span><span class="n">bestTour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findBestTour</span><span class="p">(</span><span class="n">distanceMatrix</span><span class="p">);</span>

<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Shortest Tour: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bestTour</span><span class="p">.</span><span class="na">tour</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Distance: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bestTour</span><span class="p">.</span><span class="na">distance</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Calculates the shortest tour that visits all cities.</span>
<span class="cm">     * @param distanceMatrix the distance matrix</span>
<span class="cm">     * @return the shortest tour</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="nf">findBestTour</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">[][]</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">visited</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">distanceMatrix</span><span class="p">.</span><span class="na">length</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// already fix 0 as the starting city</span>
<span class="w">        </span><span class="n">visited</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">currentTour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">currentTour</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">Result</span><span class="w"> </span><span class="n">bestTour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findBestTour</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">currentTour</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bestTour</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="nf">findBestTour</span><span class="p">(</span><span class="kt">boolean</span><span class="o">[]</span><span class="w"> </span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">currentTour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">currentLength</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[][]</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">lastCity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentTour</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">currentTour</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">currentTour</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">visited</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">currentLength</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="o">[</span><span class="n">lastCity</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span><span class="w">  </span><span class="c1">// return to city 0</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Result</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">currentTour</span><span class="p">),</span><span class="w"> </span><span class="n">currentLength</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">Result</span><span class="w"> </span><span class="n">bestResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Result</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">visited</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">currentTour</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">newLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentLength</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="o">[</span><span class="n">lastCity</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="n">Result</span><span class="w"> </span><span class="n">currentResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">findBestTour</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="n">currentTour</span><span class="p">,</span><span class="w"> </span><span class="n">newLength</span><span class="p">,</span><span class="w"> </span><span class="n">distanceMatrix</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">currentResult</span><span class="p">.</span><span class="na">distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bestResult</span><span class="p">.</span><span class="na">distance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">bestResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentResult</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">currentTour</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">currentTour</span><span class="p">.</span><span class="na">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                </span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">bestResult</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>



<span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Result</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tour</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span>

<span class="w">        </span><span class="n">Result</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">distance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">tour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tour</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<p>What is the time complexity of following algorithm?
Characterize the best and worst case.</p>
<blockquote>
<div><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Counts the minimum number of bits in the binary representation</span>
<span class="cm"> * of a positive input number. Example: 9 requires 4 bits (1001).</span>
<span class="cm"> * It halves it until it becomes zero counting the number of iterations.</span>
<span class="cm"> *</span>
<span class="cm"> * @param n The input number, which must be a positive integer.</span>
<span class="cm"> * @return The number of bits in the binary representation of the input number.</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">bitCount</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bitCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">bitCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// bitwise shift to the right, equivalent to dividing by 2</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bitCount</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</section>
</section>
</section>
<section id="space-complexity">
<h2>Space complexity<a class="headerlink" href="#space-complexity" title="Permalink to this heading">¶</a></h2>
<p>Aside from the time, the memory is also a scarce resource that is worth analyzing for an algorithm.
The <em>space complexity</em> of an algorithm quantifies the amount of space or memory taken by an algorithm to run, expressed as a function of the length of the input.
Since this notion of “space” is subject to interpretation, let us separate it into two less ambiguous definitions.</p>
<ul class="simple">
<li><p>The <em>auxiliary space</em> is the extra space or the temporary space used by the algorithm during its execution.</p></li>
<li><p>The <em>input space</em> is the space taken by the argument of the algorithm or the instance variables if any.</p></li>
</ul>
<p>The definition of space complexity includes both: <em>space complexity</em> = <em>auxiliary space complexity</em> + <em>input space complexity</em>.</p>
<p>The next <cite>sum</cite> method computing the sum of the elements in an array uses <img class="math" src="_images/math/2b213487aec26614bcae29b7c36183933319150a.svg" alt="\mathcal{O}O(1)"/> auxiliary space, but <img class="math" src="_images/math/529a0c57cd2fea8b0566dea7a79f2dd436bc280b.svg" alt="\Theta(n)"/> input space where <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> is the lenght of the input array. Its space complexity is thus <img class="math" src="_images/math/3b0cbc93b61d12574a423aa3d483093d7583b643.svg" alt="Theta(n)"/>.</p>
<blockquote>
<div><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// O(1) space for the sum variable</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>On the other hand, the method <cite>range</cite> uses <img class="math" src="_images/math/529a0c57cd2fea8b0566dea7a79f2dd436bc280b.svg" alt="\Theta(n)"/>  auxiliary space where <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/>  is the absolute value of the input parameter, but it consumes only <img class="math" src="_images/math/383f07bf3c51d10543fd52d61077438d888b4308.svg" alt="\mathcal{O}(1)"/>  input space since an integer has a fixed size encoding of 32 bits in Java.</p>
<blockquote>
<div><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="nf">range</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}}</span>
</pre></div>
</div>
</div></blockquote>
<p>Notice that we have chosen to express the space complexity in terms of the absolute value of the number. We could also have chosen to express it in terms of the input size.
The input size is 32 bits here, but in binary form, it could encode a number as large as <img class="math" src="_images/math/5603129c3ac8c5fcd7fec379ef3af5682a7b33ff.svg" alt="2^{31}-1"/> .
Therefore, if <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.svg" alt="k"/>  is the number of bits required to encode the value <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> , the auxiliary space complexity is <img class="math" src="_images/math/3e1dc0beabbc588a4cc7a73a00eb271a3dfb1cc3.svg" alt="\mathcal{O}(2^k)"/>  (exponential thus).
This illustrates the importance of clearly specifying what the parameters in a complexity expression represent when describing complexity.</p>
<section id="space-complexity-of-recursive-algorithms">
<h3>Space complexity of recursive algorithms<a class="headerlink" href="#space-complexity-of-recursive-algorithms" title="Permalink to this heading">¶</a></h3>
<p>Notice that the extra space may also take into account the space of the system stack in the case of a recursive algorithm.
In such a situation, when the recursive call happens, the current local variables are pushed onto the system stack, where they wait for the call the return and unstack the local variables.</p>
<p>More exactly, If a method <code class="docutils literal notranslate"><span class="pre">A()</span></code> calls method <code class="docutils literal notranslate"><span class="pre">B()</span></code> (which can possibly be <code class="docutils literal notranslate"><span class="pre">A()</span></code> in case of recursion) inside it, then all the variables still in the scope of the method <code class="docutils literal notranslate"><span class="pre">A()</span></code> will get stored on the system stack temporarily, while the method <code class="docutils literal notranslate"><span class="pre">B()</span></code> is called and executed inside the method <code class="docutils literal notranslate"><span class="pre">A()</span></code>.</p>
<p>Let us compare the space and time complexity of an iterative and a recursive computation of the factorial of a number expressed in function of <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/>, the value of the number for which we want to compute the factorial.</p>
<blockquote>
<div><div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Factorial</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Recursive implementation</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">factorialRecur</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorialRecur</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Iterative implementation</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">factorialIter</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Both implementations have a time complexity of <img class="math" src="_images/math/58f0a6d77dca1f8d9e6edb84fc72360f29415ae4.svg" alt="\Theta (n)"/>. However, the space complexity of the iterative version is <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>, while the one of the recursive version is <img class="math" src="_images/math/58f0a6d77dca1f8d9e6edb84fc72360f29415ae4.svg" alt="\Theta (n)"/>.</p>
<p>You may be a bit surprised by this result since no array of size <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> is ever created in the recursive version.
True! But a stack of size <code class="docutils literal notranslate"><span class="pre">n</span></code> is created. A stack? Yes, a stack, but it is not visible and it is created by the JVM.</p>
<p>Indeed, as explained before, every recursive call requires to store the local context or <em>frame</em> so that when the recursion returns, the multiplication can be performed. The sucessive frames are stored in a system stack that is transparently managed by the JVM, and that is part of the auxiliary space. The system stack for computing the factorial of 10 will look like <code class="docutils literal notranslate"><span class="pre">[10*[9*[8*[7*[6*[5*[4*[3*[2*[1]]]]]]]]]]</span></code>.
This system stack can be visualized using the IntelliJ debugger by adding a breakpoint in the method.
The call stack is shown at the bottom left of IntelliJ and you can see what the local context is by clicking on each <em>frame</em>.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/stack_factorial.png"><img alt="Sum time" src="_images/stack_factorial.png" style="width: 664.0px; height: 511.0px;" /></a>
</figure>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>It is quite frequent to have time complexity that is larger than the space complexity for an algorithm. But the opposite is not true, at least for the auxiliary space complexity.
The time complexity is necessarily at least the one of the auxiliary space complexity, because you always need the same order as elementary steps as the one of the consumed memory.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When an uncaught exception occurs, you can also visualize the output, the execution stack of the successive calls from the main method up to the line of code that caused the exception to be thrown.</p>
</div>
<section id="improving-the-space-complexity-of-merge-sort">
<h4>Improving the space complexity of merge sort<a class="headerlink" href="#improving-the-space-complexity-of-merge-sort" title="Permalink to this heading">¶</a></h4>
<p>In the <span class="xref std std-ref">merge_sort_implem</span> implementation, new arrays are created at each level of recursion.
The overall space complexity is thus of <img class="math" src="_images/math/d7c851d1765c6ac8aaa28c943087e6a8b4b3e85f.svg" alt="\mathcal{O}(n \log n)"/>, where <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> is the number of elements in the input array.
This is because, at each level of the recursion, new arrays are created in the current frame, adding up to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> elements per level, and the recursion goes <img class="math" src="_images/math/33c7abf8c20ad3622194e6b6a557f13d7e80581b.svg" alt="\log n"/> levels deep.</p>
<p>The time complexity required by our merge sort algorithm can be lowered to <img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/> for the auxiliary space.
We can indeed create a single temporary array of size <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> once and reusing it in every merge operation.
This temporary array requires <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> units of space, which is independent of the depth of the recursion.
As such, the space complexity of this version of the merge sort algorithm is <img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/>, which is an improvement over the original version.</p>
<div class="highlight-java notranslate" id="merge-sort-better"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MergeSort</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">leftEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">rightStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">leftStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftStart</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightStart</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftStart</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">leftEnd</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="n">left</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="p">;</span>
<span class="w">                </span><span class="n">right</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// copy rest of left side</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">leftEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// copy rest of right side</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">rightEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// copy temp back to original array</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">arraycopy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">leftStart</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rightEnd</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">leftStart</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">);</span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">);</span>
<span class="w">        </span><span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">leftStart</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">rightEnd</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">MergeSort</span><span class="w"> </span><span class="n">mergeSort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MergeSort</span><span class="p">();</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="mi">43</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">82</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">};</span>
<span class="w">        </span><span class="n">mergeSort</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is worth noting that in both versions of the algorithm, the time complexity remains the same: <img class="math" src="_images/math/d7c851d1765c6ac8aaa28c943087e6a8b4b3e85f.svg" alt="\mathcal{O}(n \log n)"/>.
This is because the time complexity of merge sort is determined by the number of elements being sorted (<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/>) and the number of levels in the recursion tree (<img class="math" src="_images/math/33c7abf8c20ad3622194e6b6a557f13d7e80581b.svg" alt="\log n"/>), not by the amount of space used.</p>
</section>
</section>
</section>
<section id="algorithm-correctness">
<h2>Algorithm correctness<a class="headerlink" href="#algorithm-correctness" title="Permalink to this heading">¶</a></h2>
<p>A loop invariant is a condition or property that holds before and after each iteration of a loop.
It is used as a technique for proving formally the correctness of an iterative algorithm.
The loop invariant must be true:</p>
<ol class="arabic simple">
<li><p>Before the loop begins (Initialization).</p></li>
<li><p>Before each iteration (Maintenance).</p></li>
<li><p>After the loop terminates (Termination).</p></li>
</ol>
<p>The loop invariant often helps to prove something important about the output of the algorithm.</p>
<p>The code fragment <span class="xref std std-ref">max_invariant_while</span> illustrates a simple loop invariant for
a method searching for the maximum of an array.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Finds the maximum value in the provided array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param a The array of integers.</span>
<span class="cm"> * @return The maximum integer value in the array using while loop</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// inv: m is equal to the maximum value on a[0..0]</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="na">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// inv: m is equal to the maximum value on a[0..i-1]</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// m is equal to the maximum value on a[0..i]</span>
<span class="w">        </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// inv: m is equal to the maximum value on a[0..i-1]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// m is equal to the maximum value in the entire array a[0..a.length-1]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The correctness of the <code class="docutils literal notranslate"><span class="pre">max()</span></code> algorithm is a consequence of the correctness of the invariant.
When <code class="docutils literal notranslate"><span class="pre">for</span></code> loops are used instead of <code class="docutils literal notranslate"><span class="pre">while</span></code> loops, one generally only expresses the invariant before each iteration as shown next.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// inv: m is equal to the maximum value on a[0..0]</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// inv: m is equal to the maximum value on a[0..i-1]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// m is equal to the maximum value on a[0..i]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// m is equal to the maximum value in the entire array a[0..a.length-1]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to be complete, we also need to prove that invariant itself is correctly maintained:</p>
<ul class="simple">
<li><p>Initialization: When entering the loop, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code>. The invariant is thus that <code class="docutils literal notranslate"><span class="pre">m</span></code> should contain the maximum of subarray with only the first element. Since the maximum of a single element is the element itself, the invariant holds when entering the loop.</p></li>
<li><p>Maintenance: If <code class="docutils literal notranslate"><span class="pre">m</span></code> is the maximum value in <code class="docutils literal notranslate"><span class="pre">a[0..i-1]</span></code> at the start of the loop, the current maximum either remains <code class="docutils literal notranslate"><span class="pre">m</span></code> or it becomes <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> during the iteration, ensuring it is the maximum of <code class="docutils literal notranslate"><span class="pre">a[0..i]</span></code> by the end of the iteration. So, the invariant holds for the next iteration as well.</p></li>
<li><p>Termination: At the end of the loop, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">a.length</span></code>, and based on our invariant, <code class="docutils literal notranslate"><span class="pre">m</span></code> holds the maximum value of <code class="docutils literal notranslate"><span class="pre">a[0..a.length-1]</span></code>, which means <code class="docutils literal notranslate"><span class="pre">m</span></code> is the maximum of the entire array, which proves the correctness of our algorithm.</p></li>
</ul>
<p>Let us now rewrite the <code class="docutils literal notranslate"><span class="pre">max()</span></code> algorithm in a recursive form.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Finds the maximum value in the provided array.</span>
<span class="cm"> *</span>
<span class="cm"> * @param a The array of integers.</span>
<span class="cm"> * @return The maximum integer value in the array using while loop</span>
<span class="cm"> */</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">maxRecur</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Finds the maximum value in the subarray.</span>
<span class="cm"> *</span>
<span class="cm"> * @param a The array of integers.</span>
<span class="cm"> * @param i The index, a value in [0..a.length-1].</span>
<span class="cm"> * @return The maximum value in the sub-array a[0..i]</span>
<span class="cm"> */</span>
<span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">maxRecur</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">maxRecur</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The correctness of a recursive algorithm is done by induction.
We do it on the inductive parameter <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p>
<ul class="simple">
<li><p>Base case: proof that the algorithm is correct when the algorithm is not recursing (when <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span></code> here). When <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span></code> we have <code class="docutils literal notranslate"><span class="pre">max(a[0])</span> <span class="pre">==</span> <span class="pre">a[0]</span></code>.</p></li>
<li><p>Induction: Assuming the algorithm is correct for <img class="math" src="_images/math/53f79a4e3528f8238dba280895eaa4dfd9e7bfb1.svg" alt="i-1"/>, we prove that the algorithm is correct for <img class="math" src="_images/math/5aa339d4daf45a810dda332e3c80a0698e526e04.svg" alt="i"/>.
We have that <code class="docutils literal notranslate"><span class="pre">max(a[0],...,a[i-1],a[i])</span> <span class="pre">==</span> <span class="pre">max(max(a[0],...,a[i-1]),max(a[i]))</span></code> (by associativity of <code class="docutils literal notranslate"><span class="pre">max</span></code> operation).
Then we have <code class="docutils literal notranslate"><span class="pre">max(max(a[0],...,a[i-1]),max(a[i]))</span> <span class="pre">==</span> <span class="pre">max(max(a[0],...,a[i-1]),a[i])</span></code>.
Assuming the first part is correct (this is our induction hypothesis), this expression is precisely the one we compute.</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<blockquote>
<div><p>Find an invariant for the loop of the bubble <span class="xref std std-ref">maxsum</span> algorithm.
Prove that the invariant is correctly maintained.
Hint: Your invariant should express a property on the variables <code class="docutils literal notranslate"><span class="pre">maxCurrent</span></code> and <code class="docutils literal notranslate"><span class="pre">maxGlobal</span></code> with respect to index <code class="docutils literal notranslate"><span class="pre">i</span></code>.
A good exercise is to write a recursive version of this algorithm and to write the specification of it.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MaxSubArray</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Computes the sum of the maximum contiguous subarray.</span>
<span class="cm">     * Example:</span>
<span class="cm">     *   int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};</span>
<span class="cm">     *   maxSubArray(nums);  // Returns 6, for subarray [4, -1, 2, 1].</span>
<span class="cm">     *</span>
<span class="cm">     * @param nums An array of integers.</span>
<span class="cm">     * @return The sum of the maximum subarray.</span>
<span class="cm">     *</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">maxSubArray</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">maxCurrent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">maxGlobal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// invariant</span>
<span class="w">            </span><span class="n">maxCurrent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">maxCurrent</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">);</span>
<span class="w">            </span><span class="n">maxGlobal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">(</span><span class="n">maxGlobal</span><span class="p">,</span><span class="w"> </span><span class="n">maxCurrent</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">maxGlobal</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">maxSubArray</span><span class="p">(</span><span class="n">nums</span><span class="p">));</span><span class="w">  </span><span class="c1">// Outputs 6</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<blockquote>
<div><p>Find an invariant for the outer loop of the bubble <span class="xref std std-ref">bubble_loop</span> sort algorithm.
Prove that the invariant is correctly maintained.
Hint: Your invariant should express a property on the array with respect to index <code class="docutils literal notranslate"><span class="pre">i</span></code>.
A subpart of the array is already sorted? What values are they?</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Main</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">};</span>
<span class="w">        </span><span class="n">bubbleSort</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// invariant</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// swap array[j] and array[j+1]</span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="w">                    </span><span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</section>
<section id="abstract-data-types-adt">
<h2>Abstract Data Types (ADT)<a class="headerlink" href="#abstract-data-types-adt" title="Permalink to this heading">¶</a></h2>
<p>In the context of data collection, an Abstract Data Type (ADT) is a high-level description of a collection of data and of the operations that can be performed on this data.</p>
<p>An ADT can best be described by an interface in Java. This interface specifies what operations can be done on the data, but without prescribing how these operations will be implemented.
Implementation details are abstracted away.</p>
<p>It means that the underlying implementation of an ADT can change without affecting how the users of the ADT interact with it.</p>
<p>Abstract Data Types are present in the Java Collections Framework.
Let’s consider the <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>  interface that belongs to the standard <code class="docutils literal notranslate"><span class="pre">java.util</span></code> namespace.
This is one of the most frequently used Abstract Data Types.
It defines an ordered collection of elements, with duplicates allowed.
<code class="docutils literal notranslate"><span class="pre">List</span></code> is an ADT because it specifies a set of operations (e.g., <code class="docutils literal notranslate"><span class="pre">add(E</span> <span class="pre">e)</span></code>, <code class="docutils literal notranslate"><span class="pre">get(int</span> <span class="pre">index)</span></code>, <code class="docutils literal notranslate"><span class="pre">remove(int</span> <span class="pre">index)</span></code>, <code class="docutils literal notranslate"><span class="pre">size()</span></code>) that you can perform on a list without specifying how these operations are concretely implemented.</p>
<p>To get a concrete implementation of a <code class="docutils literal notranslate"><span class="pre">List</span></code>, you must use one of the concrete classes that implement this interface,
for instance <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> or <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html">LinkedList</a>.
Whatever the one you choose the high level contract described at the interface level remain the same, although depending on the instanciation you might have different behaviors in terms of speed for example.</p>
<p>One example of the <code class="docutils literal notranslate"><span class="pre">List</span></code> ADT is given next.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.LinkedList</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.List</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LinkedListExample</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fruits</span><span class="p">;</span><span class="w"> </span><span class="c1">// declaring a List ADT reference</span>

<span class="w">        </span><span class="n">fruits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Initializing it using LinkedList</span>
<span class="w">        </span><span class="c1">// fruits = new ArrayList&lt;&gt;(); This would also work using ArrayList instead</span>

<span class="w">        </span><span class="c1">// Adding elements</span>
<span class="w">        </span><span class="n">fruits</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;Apple&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">fruits</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;Banana&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">fruits</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;Cherry&quot;</span><span class="p">);</span>


<span class="w">        </span><span class="c1">// Removing an element</span>
<span class="w">        </span><span class="n">fruits</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="s">&quot;Banana&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above, you see the special notation <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> that is associated with <a class="reference internal" href="part2.html#generics"><span class="std std-ref">generics</span></a> in Java.
Generics correspond to the concept of type parameters, allowing you to write code that is parameterized by one or more types.
The core idea is to allow type (classes and interfaces) to be parameters when defining classes, interfaces, and methods.</p>
<p>This enables you to create generic algorithms that can work on collections of different types, classes, interfaces, and methods that operate on a parameterized type.
Generics offer a way to define and enforce strong type-checks at compile-time without committing to a specific data type.</p>
<p>Java introduced support for generics in 2004, as a part of Java 5 (formally referred to as J2SE 5.0). In earlier versions of Java generics did not exit.
You could add any type of object to collections, which was prone to runtime type-casting errors, as illustrated in this example:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.LinkedList</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.List</span><span class="p">;</span>

<span class="n">List</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="p">();</span>
<span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// This is fine without generics</span>
<span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// ClassCastException at runtime</span>
</pre></div>
</div>
<p>With generics, the type of elements you can add is restricted at compile-time, eliminating the potential for <code class="docutils literal notranslate"><span class="pre">ClassCastException</span></code> at runtime. In the example above, you would have used the <code class="docutils literal notranslate"><span class="pre">List&lt;String&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">ArrayList&lt;String&gt;</span></code> parametrized classes instead of the <code class="docutils literal notranslate"><span class="pre">List</span></code> and <code class="docutils literal notranslate"><span class="pre">ArrayList</span></code> plain classes. Consequently, the call to <code class="docutils literal notranslate"><span class="pre">list.add(1)</span></code> would have resulted in a compilation error, because <code class="docutils literal notranslate"><span class="pre">1</span></code> is not a <code class="docutils literal notranslate"><span class="pre">String</span></code>.</p>
<p>Generics enable you to write generalized algorithms and classes based on parameterized types, making it possible to reuse the same method, class, or interface for different data types.</p>
<section id="stack-adt">
<h3>Stack ADT<a class="headerlink" href="#stack-adt" title="Permalink to this heading">¶</a></h3>
<p>Let us now study in-depth an ADT called <code class="docutils literal notranslate"><span class="pre">Stack</span></code> that is also frequently used by programmers.
A stack is a collection that operates on a Last-In-First-Out (LIFO) principle.
The primary operations of a <code class="docutils literal notranslate"><span class="pre">Stack</span></code> are <code class="docutils literal notranslate"><span class="pre">push()</span></code>, <code class="docutils literal notranslate"><span class="pre">pop()</span></code>, and <code class="docutils literal notranslate"><span class="pre">peek()</span></code>, as described in the next interface:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Pushes an item onto the top of this stack.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Removes and returns the top item from this stack.</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns the top item from this stack without removing it.</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">peek</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns true if this stack is empty.</span>
<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isEmpty</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns the number of items in this stack.</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let us now see some possible concrete implementations of this interface.</p>
<section id="implementing-a-stack-with-a-linked-structure">
<span id="linked-stack-adt"></span><h4>Implementing a Stack With a Linked Structure<a class="headerlink" href="#implementing-a-stack-with-a-linked-structure" title="Permalink to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">LinkedStack</span></code> is an implementation of the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> ADT that uses a linked list structure to store its elements.
Each element in the stack is stored in a node, and each node has a reference to the next node (like individual wagons are connected in a train).
The top of the stack is maintained as a reference to the first node (head) of the linked list.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LinkedStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>

<span class="w">        </span><span class="n">Node</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">);</span>
<span class="w">        </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">.</span><span class="na">item</span><span class="p">;</span>
<span class="w">        </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="p">.</span><span class="na">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isEmpty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The state of the linked stack after pushing 1, 5 and 3 in this order is illustrated on the next figure.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/list.png"><img alt="LinkedStack" src="_images/list.png" style="width: 531.0px; height: 101.0px;" /></a>
</figure>
</section>
<section id="implementing-a-stack-with-an-array">
<h4>Implementing a Stack With an Array<a class="headerlink" href="#implementing-a-stack-with-an-array" title="Permalink to this heading">¶</a></h4>
<p>Another method for implementing the <code class="docutils literal notranslate"><span class="pre">Stack</span></code> ADT is by utilizing an internal array to hold the elements.
An implementation is given in the next code fragment:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DynamicArrayStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">T</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">DynamicArrayStack</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">initialCapacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">[]</span><span class="p">)</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="o">[</span><span class="n">initialCapacity</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="p">);</span><span class="w"> </span><span class="c1">// double the size</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">array</span><span class="o">[++</span><span class="n">top</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">top</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">array</span><span class="o">[</span><span class="n">top</span><span class="o">--]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w"> </span><span class="c1">// to prevent memory leak</span>

<span class="w">        </span><span class="c1">// shrink the size if necessary</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">resize</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">peek</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">top</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isEmpty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">resize</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">newCapacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="o">[]</span><span class="w"> </span><span class="n">newArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">[]</span><span class="p">)</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="o">[</span><span class="n">newCapacity</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">top</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">newArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newArray</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The internal array is initialized with a size larger than the expected number of elements in the stack to prevent frequent resizing.</p>
<p>An integer variable, often termed <code class="docutils literal notranslate"><span class="pre">top</span></code> or <code class="docutils literal notranslate"><span class="pre">size</span></code>, represents the current position in the stack. When pushing a new element onto the stack, it is added at the position indicated by this integer. Subsequently, the integer is incremented. The <code class="docutils literal notranslate"><span class="pre">pop()</span></code> operation reverses this process: The element at the current position is retrieved, and the integer is decremented. Both the <code class="docutils literal notranslate"><span class="pre">push()</span></code> and <code class="docutils literal notranslate"><span class="pre">pop()</span></code> operations have constant time complexity: <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>.</p>
<p>However, there’s an inherent limitation when using arrays in Java: Their size is fixed upon creation. Thus, if the stack’s size grows to match the internal array’s size, any further push operation risks an <code class="docutils literal notranslate"><span class="pre">ArrayIndexOutOfBoundsException</span></code>.</p>
<p>To counteract this limitation, when the internal array is detected to be full, its size is doubled. This is achieved by creating a new array whose capacity is doubled with respect to the current array, then copying the contents of the current array to the new one. Although this resizing operation has a linear time complexity of <img class="math" src="_images/math/3c582d9a5675f447fdb2947388ed396388789dba.svg" alt="O(n)"/>, where
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> is the number of elements, it doesn’t happen often.</p>
<p>In addition, to avoid inefficiencies in terms of memory usage, if the size of the stack drops to one-quarter of the internal array’s capacity, the array size is halved. This prevents the array from being overly sparse and consuming unnecessary memory.</p>
<p>Although resizing (either increasing or decreasing the size) requires <img class="math" src="_images/math/3c582d9a5675f447fdb2947388ed396388789dba.svg" alt="O(n)"/> time in the worst case, this cost is distributed over many operations, making the average cost constant. This is known as amortized analysis. Thus, when analyzed in an amortized sense, the average cost per operation over
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> operations is <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>.</p>
</section>
<section id="evaluating-arithmetic-expressions-with-a-stack">
<h4>Evaluating Arithmetic Expressions with a Stack<a class="headerlink" href="#evaluating-arithmetic-expressions-with-a-stack" title="Permalink to this heading">¶</a></h4>
<p>A typical use of stacks is to evaluate arithmetic expressions, as demonstrated in the next algorithm:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ArithmeticExpression</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="s">&quot;( ( 2 * ( 3 + 5 ) ) / 4 )&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ops</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedStack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedStack</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p">.</span><span class="na">split</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// INVARIANT</span>
<span class="w">            </span><span class="k">if</span><span class="w">      </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">))</span><span class="w">               </span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">ops</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">ops</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">ops</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">ops</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">String</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ops</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span>
<span class="w">                </span><span class="kt">double</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span>
<span class="w">                </span><span class="k">if</span><span class="w">      </span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">))</span><span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">                </span><span class="n">vals</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="n">Double</span><span class="p">.</span><span class="na">parseDouble</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">vals</span><span class="p">.</span><span class="na">pop</span><span class="p">();</span>

<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The time complexity of the algorithm is clearly <img class="math" src="_images/math/3c582d9a5675f447fdb2947388ed396388789dba.svg" alt="O(n)"/> where <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.svg" alt="n"/> is the size of the input string:</p>
<ul class="simple">
<li><p>Each token (whether it is a number, operator, or parenthesis) in the expression is read and processed exactly once.</p></li>
<li><p>Pushing and popping elements from a stack take constant time, <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>.</p></li>
<li><p>Arithmetic operations (addition, subtraction, multiplication, and division) are performed in constant time, <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>.</p></li>
</ul>
<p>To understand and convince one-self about the correctness of the algorithm, we should try to discover an invariant.
As can be seen, a fully parenthesized expression can be represented as a binary tree where the parenthesis are not necessary:</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/expression.png"><img alt="Arithmetic Expression" src="_images/expression.png" style="width: 523.0px; height: 653.0px;" /></a>
</figure>
<p>The internal nodes are the operator and the leaf nodes are the values.
The algorithm uses two stacks. One stack (<code class="docutils literal notranslate"><span class="pre">ops</span></code>) is for operators and the other (<code class="docutils literal notranslate"><span class="pre">vals</span></code>) is for (reduced) values.
The program splits the input string <code class="docutils literal notranslate"><span class="pre">args[0]</span></code> by spaces to process each token of the expression individually.</p>
<p>We will not formalize completely the invariant here but give some intuition about what it is.</p>
<p>At any point during the processing of the expression:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack contains the results of all fully evaluated sub-expressions (reduced subtrees) encountered so far.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ops</span></code> stack contains operators that are awaiting their right-hand operands to form a complete sub-expression (subtree) that can be reduced.</p></li>
<li><p>For every operator in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> stack, its corresponding left-hand operand is already in the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack, awaiting the completion of its subtree for reduction.</p></li>
</ol>
<p>The figure displays the status of the stacks at three distinct stages for our brief example.</p>
<p>When we encounter an operand, it is like encountering a leaf of this tree, and we immediately know its value, so it is pushed onto the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack.</p>
<p>When we encounter an operator, it is pushed onto the <code class="docutils literal notranslate"><span class="pre">ops</span></code> stack. This operator is awaiting its right-hand operand to form a complete subtree. Its left-hand operand is already on the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack.</p>
<p>When a closing parenthesis <code class="docutils literal notranslate"><span class="pre">)</span></code> is encountered, it indicates the end of a fully parenthesized sub-expression, corresponding to an entire subtree of the expression. This subtree is “reduced” or “evaluated” in the following manner:</p>
<ol class="arabic simple">
<li><p>The operator for this subtree is popped from the <code class="docutils literal notranslate"><span class="pre">ops</span></code> stack.</p></li>
<li><p>The right-hand operand (the value of the right subtree) is popped from the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack.</p></li>
<li><p>The left-hand operand (the value of the left subtree) is popped from the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack.</p></li>
<li><p>The operator is applied to the two operands, and the result (the value of the entire subtree) is pushed back onto the <code class="docutils literal notranslate"><span class="pre">vals</span></code> stack.</p></li>
</ol>
<p>This invariant captures the essence of the algorithm’s approach to the problem: It traverses the expression tree in a sort of depth-first manner, evaluating each subtree as it is fully identified by its closing parenthesis.</p>
<p>This algorithm taking a <code class="docutils literal notranslate"><span class="pre">String</span></code> as its input is a an example of an interpreter.
Interpreted programming languages (like Python) do similarly but accept constructs that a slightly more complex that parenthesized arithmetic expressions.</p>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<p>Write an recursive algorithm for evaluation arithmetic expressions.
This program will not use explicit stacks but rely on the call stack instead.</p>
</div>
</section>
</section>
<section id="trees">
<h3>Trees<a class="headerlink" href="#trees" title="Permalink to this heading">¶</a></h3>
<p>In many applications, there is a need to store and manage hierarchically organized data. Examples include representing family trees (genealogy), structuring the way files are stored on your computer, or representing arithmetic expressions.</p>
<p>Consider the following example where we represent data using a tree structure.</p>
<figure class="align-default" id="id9">
<a class="reference internal image-reference" href="_images/binary_tree.png"><img alt="Binary Tree example" src="_images/binary_tree.png" style="width: 172.2px; height: 280.7px;" /></a>
<figcaption>
<p><span class="caption-text">BinaryTree</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>A tree is often represented with the root node at the top (in this case, the node with the value 5) and the leaf nodes (the ones without children) at the bottom.</p>
<p>The <cite>LinkedBinaryTree</cite> class shown below is an implementation for representing such a tree data-structure.
In this class, each node contains a value and references to its left and right children.
This structure is similar to the nodes used in linked lists, with the key difference being that we store two references (one for each child) instead of just one.
This class facilitates the creation of leaf nodes and includes a static helper method called <cite>combine</cite>,
which allows us to merge two trees by creating a new root node, thus forming a larger binary tree.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LinkedBinaryTree</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>

<span class="w">        </span><span class="kd">class</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">            </span><span class="kd">public</span><span class="w"> </span><span class="nf">Node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="nf">leaf</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="p">();</span>
<span class="w">            </span><span class="n">tree</span><span class="p">.</span><span class="na">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="na">new</span><span class="w"> </span><span class="nf">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBinaryTree</span><span class="p">();</span>
<span class="w">            </span><span class="n">tree</span><span class="p">.</span><span class="na">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="na">new</span><span class="w"> </span><span class="nf">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">            </span><span class="n">tree</span><span class="p">.</span><span class="na">root</span><span class="p">.</span><span class="na">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">root</span><span class="p">;</span>
<span class="w">            </span><span class="n">tree</span><span class="p">.</span><span class="na">root</span><span class="p">.</span><span class="na">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">root</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-java notranslate" id="binary-tree"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LinkedBinaryTree</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span>
<span class="w">                               </span><span class="n">combine</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span>
<span class="w">                                       </span><span class="n">leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="w">                                       </span><span class="n">combine</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">combine</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span>
<span class="w">                                                       </span><span class="n">leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="w">                                                       </span><span class="n">leaf</span><span class="p">(</span><span class="mi">7</span><span class="p">)),</span>
<span class="w">                                               </span><span class="n">leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">))),</span>
<span class="w">                               </span><span class="n">leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="tree-traversals">
<h4>Tree Traversals<a class="headerlink" href="#tree-traversals" title="Permalink to this heading">¶</a></h4>
<p>Tree traversal strategies are methods used to visit all the nodes in a tree, such as a binary tree.
The three common traversal strategies are pre-order, in-order, and post-order.
Here’s a brief explanation of each:</p>
<ul class="simple">
<li><p>Pre-order traversal visits the current node, then traverse the left subtree, and finally, traverse the right subtree.</p></li>
<li><p>In-order traversal traverses the left subtree, visit the current node, and then traverse the right subtree.</p></li>
<li><p>Post-order Traversal traverses the left subtree, then the right subtree, and finally visit the current node.</p></li>
</ul>
<p>The code for each traversal is given next.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">preOrderPrint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">preOrderPrint</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">preOrderPrint</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">preOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">preOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">inOrderPrint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inOrderPrint</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">inOrderPrint</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">inOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">inOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postOrderPrint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">postOrderPrint</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postOrderPrint</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">postOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">postOrderPrint</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="p">);</span>
<span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">print</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is the output order obtained on the binary represented <span class="xref std std-ref">binary-tree</span> for each traversals:</p>
<ul class="simple">
<li><p>Pre-Order: 5, 8, 2, 7, 6, 5, 7, 3, 3</p></li>
<li><p>In-Order: 2, 8, 5, 6, 7, 7, 3, 5, 3</p></li>
<li><p>Post-Order: 2, 5, 7, 6, 3, 7, 8, 3, 5</p></li>
</ul>
<p>Visiting a binary tree with <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes takes <img class="math" src="_images/math/529a0c57cd2fea8b0566dea7a79f2dd436bc280b.svg" alt="\Theta(n)"/> (assuming the visit of one node takes a constant time),
since each node is visited exactly once.</p>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<p>Write an iterative algorithm (not recursive) for implementing each of these traversals.
You will need to use an explicit stack.</p>
</div>
<p>We show next two practical examples using binary trees data-structures.</p>
</section>
<section id="representing-an-arithmetic-expression-with-tree">
<span id="arithmetic-expression"></span><h4>Representing an arithmetic Expression with Tree<a class="headerlink" href="#representing-an-arithmetic-expression-with-tree" title="Permalink to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">BinaryExpressionTree</span></code> class in the provided code is an abstract representation of a binary expression tree,
a data structure commonly used in computer science for representing expressions with binary operators (like <code class="docutils literal notranslate"><span class="pre">+,</span> <span class="pre">-,</span> <span class="pre">*,</span> <span class="pre">/</span></code>).</p>
<p>The set of expression methods (<code class="docutils literal notranslate"><span class="pre">mul()</span></code>, <code class="docutils literal notranslate"><span class="pre">div()</span></code>, <code class="docutils literal notranslate"><span class="pre">plus()</span></code>, <code class="docutils literal notranslate"><span class="pre">minus()</span></code>) allows to build easily expressions from other expressions.
These methods return a new <code class="docutils literal notranslate"><span class="pre">OperatorExpressionTree</span></code> object, which is a subclass of <code class="docutils literal notranslate"><span class="pre">BinaryExpressionTree</span></code>.
Each method takes another <code class="docutils literal notranslate"><span class="pre">BinaryExpressionTree</span></code> as an operand to the right of the operator.
The private static nested class <code class="docutils literal notranslate"><span class="pre">OperatorExpressionTree</span></code> represents an operator node in the tree with left and right children, which are also BinaryExpressionTree instances.
The private static nested class <code class="docutils literal notranslate"><span class="pre">ValueExpressionTree</span></code>  represents a leaf node in the tree that contains a value.
A convenience static method <code class="docutils literal notranslate"><span class="pre">value()</span></code> allows creating a <code class="docutils literal notranslate"><span class="pre">ValueExpressionTree</span></code> with a given integer value.
An example is provided in the main method for creating tree representation of the expression <code class="docutils literal notranslate"><span class="pre">(2</span> <span class="pre">*</span> <span class="pre">((5+7)-3))</span> <span class="pre">/</span> <span class="pre">3</span></code>.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="nf">mul</span><span class="p">(</span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OperatorExpressionTree</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="nf">div</span><span class="p">(</span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OperatorExpressionTree</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="nf">plus</span><span class="p">(</span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OperatorExpressionTree</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="nf">minus</span><span class="p">(</span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OperatorExpressionTree</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OperatorExpressionTree</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">operator</span><span class="p">;</span>

<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">OperatorExpressionTree</span><span class="p">(</span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">operator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">operator</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ValueExpressionTree</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">ValueExpressionTree</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ValueExpressionTree</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="na">mul</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="na">plus</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="mi">7</span><span class="p">)).</span><span class="na">minus</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)).</span><span class="na">div</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)));</span><span class="w"> </span><span class="c1">// (2 * ((5+7)-3)) / 3</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<p>We now enrich this class with two functionalities:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">evaluate()</span></code> is a method for evaluating the expression represented by the tree. This method performs a post-order traversal of the tree. The evaluation of the left sub-expression (left traversal) and the right subexpression (right traversal) must be first evaluated prior to applying the node operator (visit of the node).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prettyPrint()</span></code> is a method for printing the expression as full parenthesized representation. It corresponds to an infix traversal. The left subexpression is printed (left traversal) before printing the node operator (visit of the node) and then printing the right subexpression (right traversal).</p></li>
</ul>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// evaluate the expression</span>
<span class="w">    </span><span class="kd">abstract</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// print a fully parenthesized representation of the expression</span>
<span class="w">    </span><span class="kd">abstract</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">prettyPrint</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// mul , div, plus, minus not represented</span>


<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OperatorExpressionTree</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">operator</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// constructor not represented</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">prettyPrint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">prettyPrint</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">prettyPrint</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">leftRes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">.</span><span class="na">evaluate</span><span class="p">();</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">rightRes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="na">evaluate</span><span class="p">();</span>
<span class="w">            </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">operator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">:</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">leftRes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rightRes</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">:</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">leftRes</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">rightRes</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="p">:</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">leftRes</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">rightRes</span><span class="p">;</span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="p">:</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">leftRes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rightRes</span><span class="p">;</span>
<span class="w">                </span><span class="k">default</span><span class="p">:</span>
<span class="w">                    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;unkown operator &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">operator</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ValueExpressionTree</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">BinaryExpressionTree</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// constructor not represented</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">prettyPrint</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<p>Enrich the BinaryExpressionTree with a method <code class="docutils literal notranslate"><span class="pre">rpnPrint()</span></code> to print the expression in <em>reverse Polish notation</em>.
In reverse Polish notation, the operators follow their operands. For example, to add 3 and 4 together, the expression is <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">+</span></code> rather than <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">+</span> <span class="pre">4</span></code>.
This notation doesn’t need parenthesis: <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">×</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">(5</span> <span class="pre">×</span> <span class="pre">6)</span></code> becomes <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">×</span> <span class="pre">5</span> <span class="pre">6</span> <span class="pre">×</span> <span class="pre">+</span></code> in reverse Polish notation.</p>
</div>
</section>
<section id="representing-a-set-with-a-binary-search-tree-bst">
<h4>Representing a set with a Binary Search Tree (BST)<a class="headerlink" href="#representing-a-set-with-a-binary-search-tree-bst" title="Permalink to this heading">¶</a></h4>
<p>An Abstract Data Type (ADT) for representing a set of integers without duplicates is provided below.
The set is initially empty. Elements can then be added, and it is possible to check if an element has already been added.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">IntSet</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A Binary Search Tree (BST) is a specialized type of binary tree that can be used as
a data-structure for implementing the IntSet ADT.
In a BST, each node stores a value, and all nodes in the left subtree of a node
contain values less than the node’s value, while all nodes in the right subtree contain values greater than the node’s value.</p>
<p>These properties ensure that the tree remains ordered, which is crucial for the efficiency of operations like search, insertion, and deletion.</p>
<p>A valid BST is shown on the left, while an invalid BST is displayed on the right.
The tree on the right is not valid because the value 14 appears in the left subtree of the node with value 13, which violates the BST rule.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/bst_example.png"><img alt="A valide BST, an Invalid BST" src="_images/bst_example.png" style="width: 298.0px; height: 200.5px;" /></a>
</figure>
<dl class="simple">
<dt>The <cite>BinarySearchTree</cite> class defined below, implements <cite>IntSet</cite></dt><dd><p>for storing a set of integers.</p>
</dd>
</dl>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BinarySearchTree</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">IntSet</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">Node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Method to add a value to the tree</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addRecursive</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="nf">addRecursive</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addRecursive</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addRecursive</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="c1">// if val equals current.val, the value already exists, do nothing</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Method to check if the tree contains a specific value</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">containsRecursive</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">containsRecursive</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">val</span>
<span class="w">                </span><span class="o">?</span><span class="w"> </span><span class="n">containsRecursive</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">left</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<span class="w">                </span><span class="p">:</span><span class="w"> </span><span class="n">containsRecursive</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="na">right</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Main method for testing</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BinarySearchTree</span><span class="w"> </span><span class="n">bst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BinarySearchTree</span><span class="p">();</span>
<span class="w">        </span><span class="n">bst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">        </span><span class="n">bst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="n">bst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="w">        </span><span class="n">bst</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Contains 3: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bst</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"> </span><span class="c1">// true</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Contains 6: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bst</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span><span class="w"> </span><span class="c1">// false</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We reuse the linked node representation.
The <cite>add(int val)</cite> method allows us to insert a new value into the tree.
This method calls <cite>addRecursive(Node current, int val)</cite>, which recursively traverses the tree:</p>
<ul class="simple">
<li><p>If the current node is <cite>null</cite>, a new node with the value <cite>val</cite> is created.</p></li>
<li><p>If <cite>val</cite> is less than the current node’s value, the algorithm moves (recursively) to the left child.</p></li>
<li><p>If <cite>val</cite> is greater, it moves (recursively) to the right child.</p></li>
<li><p>If <cite>val</cite> is equal to the current node’s value, no action is taken (to avoid duplicates).</p></li>
</ul>
<p>The recursion ensures that the new value is inserted at the correct position according to the BST properties.</p>
<p>The time complexity for insertion is <img class="math" src="_images/math/b94a3e485aae3474eaddeac2563a1b2126aaaafc.svg" alt="\mathcal{O}(h)"/>, where <img class="math" src="_images/math/4c120f773ab4e1c59ad2bd44aae969ce24dd190a.svg" alt="h"/> is the height of the tree.
Since no guarantees on <img class="math" src="_images/math/4c120f773ab4e1c59ad2bd44aae969ce24dd190a.svg" alt="h"/> can be made with this implementation,
the height should be assumed to be <img class="math" src="_images/math/a5dc115d222c2fc427115a54fb7bcf899a90725b.svg" alt="\mathcal{O}(n)"/>, the number of nodes. This worst-case scenario occurs when the tree is highly unbalanced, resembling a linked list. This situation can arise, for instance, if the keys are inserted in increasing order.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>There exist more complex implementations of a BST to enforce <img class="math" src="_images/math/4c120f773ab4e1c59ad2bd44aae969ce24dd190a.svg" alt="h"/> is in <img class="math" src="_images/math/618acd823fafc7ceb01b070ff9c53108bb15f00a.svg" alt="\mathcal{O}(log(n))"/>. The most famous one is called a red-black tree.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Exercise</p>
<p>One traversal strategy allows to iterate over the values of the BST in increasing order in linear time. Which one is it? Can you implement it?</p>
</div>
</section>
</section>
<section id="maps">
<span id="iterators"></span><h3>Maps<a class="headerlink" href="#maps" title="Permalink to this heading">¶</a></h3>
<p>An array in Java is a data structure that stores elements in a fixed order. Each element in the array is accessed using an index, which is a integer.</p>
<p>A Map is an ADT that generalizes the idea of indexing to be more flexible by allowing the index to be something else than an integer.
In Map, the index is called a key, and each key maps it to a value.
An example usage of Map is given next making use of the two most important methods,
the <cite>put</cite> to add a key, value pair (aka entry)  and the <cite>get</cite> to retrieve the value from the key.
Ìn Java, <cite>java.util.`Map</cite> is the interface for the Map ADT.
It is implemented by the class <cite>java.util.HashTable</cite> (and many others).</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Hashtable</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Map</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MapExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Create a HashMap to store tree names and their heights</span>
<span class="w">        </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">treeHeights</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashTable</span><span class="o">&lt;&gt;</span><span class="p">();</span>

<span class="w">        </span><span class="c1">// Add some key-value pairs (tree names and their average heights in meters)</span>
<span class="w">        </span><span class="n">treeHeights</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;Oak&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">        </span><span class="n">treeHeights</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;Pine&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">);</span>
<span class="w">        </span><span class="n">treeHeights</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;Maple&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span>
<span class="w">        </span><span class="n">treeHeights</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;Birch&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Retrieve the height of a specific tree</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Height of Oak: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">treeHeights</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&quot;Oak&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Output: 20</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An illustration of the internal representation of hash table is given next.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="_images/hash_tables.png"><img alt="Illustration of the underlying time-table" src="_images/hash_tables.png" style="width: 578.0px; height: 441.0px;" /></a>
</figure>
<p>A hash table stores keys and values as entries (key-value pairs) in a Java array. At the core of a hash table is the concept of hashing. A hash function takes a key (in this case, a string) and converts it into an integer, known as the hash code. It is crucial that this function is deterministic, meaning the hash code for a given key must always remain the same.</p>
<p>The purpose of the hash code is to determine where a specific key should be stored in the internal array. In Java, every object has a <cite>hashCode</cite> method that returns an integer (which can sometimes be negative). To map this hash code to a valid index between 0 and N-1 (where N is the size of the array), we first take its absolute value and then apply the % (modulo) operator.</p>
<p>When inserting a new entry into the hash table, there is no guarantee that the computed index will be unoccupied. This situation, known as a <em>collision</em>, occurs when multiple keys are mapped to the same index. To handle collisions, a linked list is used at each index of the array to store multiple entries.</p>
<p>Collisions become more frequent as the number of entries in the hash table grows compared to the size of the array N. The efficiency of the hash table largely depends on the assumption that the hash function distributes keys uniformly across the array and that the number of entries is kept lower than N. However, these topics go beyond the scope of this brief introduction to hash tables.
Insertion and retrieval can be assumed to have an expected time complexity of <img class="math" src="_images/math/383f07bf3c51d10543fd52d61077438d888b4308.svg" alt="\mathcal{O}(1)"/> for the <cite>java.util.HashTable</cite> implementation because the load factor (ratio of the number of entries divided by N) is kept low by resizing the table if necessary similarly as in the stack implementation with an array.</p>
<p>A simple implementation is given next.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.LinkedList</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SimpleHashtable</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="c1">// Size of the internal array</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Each entry in the array is a LinkedList to handle collisions</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;[]</span><span class="w"> </span><span class="n">table</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Constructor initializes the array</span>
<span class="w">    </span><span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&quot;unchecked&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">SimpleHashtable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// A private class representing a key-value pair</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">Integer</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>

<span class="w">        </span><span class="n">Entry</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Hash function to calculate the index for a given key</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hash</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">abs</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">())</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Put method to insert or update a key-value pair</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">put</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bucket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Check if the key already exists, if so, update its value</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Entry</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">bucket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">entry</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// If the key doesn&#39;t exist, add a new Entry to the bucket</span>
<span class="w">        </span><span class="n">bucket</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Entry</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Get method to retrieve the value associated with a key</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bucket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Iterate through the bucket to find the key</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Entry</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">bucket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Return null if the key is not found</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id7">
<h2>Iterators<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>An iterator is an object that facilitates the traversal of a data structure, especially collections, in a systematic manner without exposing the underlying details of that structure. The primary purpose of an iterator is to allow a programmer to process each element of a collection, one at a time, without needing to understand the inner workings or the specific memory layout of the collection.</p>
<p>Java provides an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> interface in the <code class="docutils literal notranslate"><span class="pre">java.util</span></code> package, which is implemented by various collection classes. This allows objects of those classes to create iterator instances on demand that can be used to traverse through the collection.</p>
<p>An iterator acts like a cursor pointing to some element within the collection.
The two important methods of an iterator are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hasNext()</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if and only if there are more elements to iterate over.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">next()</span></code>: Returns the next element in the collection and advances the iterator. This method fails if <code class="docutils literal notranslate"><span class="pre">hasNext()</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<p>The method <code class="docutils literal notranslate"><span class="pre">remove()</span></code> is optional and will not be covered in this course.</p>
<p>The next example show how to use an iterator to print every element of a list.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ArrayList</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Iterator</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">IteratorExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="na">iterator</span><span class="p">();</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="na">hasNext</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">String</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="p">.</span><span class="na">next</span><span class="p">();</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Iterable</span></code> should not be confused with <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>.
It is also an interface in Java, found in the <code class="docutils literal notranslate"><span class="pre">java.lang</span> <span class="pre">package</span></code>.
An object is “iterable” if it implements the <code class="docutils literal notranslate"><span class="pre">Iterable</span></code> interface which has a single method:
<code class="docutils literal notranslate"><span class="pre">Iterator&lt;T&gt;</span> <span class="pre">iterator();</span></code>.
This essentially means that the object has the capability to provide an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> over itself.</p>
<p>Many data structures (like lists, sets, and queues) in the <code class="docutils literal notranslate"><span class="pre">java.util.collections</span></code> package implement the <code class="docutils literal notranslate"><span class="pre">Iterable</span></code> interface to provide a standardized method to iterate over their elements.</p>
<p>One of the main benefits of the <code class="docutils literal notranslate"><span class="pre">Iterable</span></code> interface is that it allows objects to be used with the <a class="reference internal" href="part1.html#simple-for-loops"><span class="std std-ref">enhanced for-each loop</span></a> in Java.
Any class that implements <code class="docutils literal notranslate"><span class="pre">Iterable</span></code> can be used in a for-each loop.
This is illustrated next that is equivalent to the previous code.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ArrayList</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Iterator</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">IteratorExample</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">element</span><span class="p">:</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In conclusion, while they are closely related and often used together, <code class="docutils literal notranslate"><span class="pre">Iterable</span></code> and <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> serve distinct purposes.
<code class="docutils literal notranslate"><span class="pre">Iterable</span></code> is about the ability to produce an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>, while <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> is the mechanism that actually facilitates the traversal.</p>
<section id="implementing-your-own-iterators">
<span id="custom-iterators"></span><h3>Implementing your own iterators<a class="headerlink" href="#implementing-your-own-iterators" title="Permalink to this heading">¶</a></h3>
<p>The correct way to enable iteration capabilities is to extend the Iterable interface at the Abstract Data Type (ADT) level.
This ensures that any implementation of the ADT is required to implement the iterator method defined by the Iterable interface.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Pushes an item onto the top of this stack.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Removes and returns the top item from this stack.</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns the top item from this stack without removing it.</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="nf">peek</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns true if this stack is empty.</span>
<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isEmpty</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Returns the number of items in this stack.</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now to properly implement an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>, there are two possible strategies:</p>
<ol class="arabic simple">
<li><p>Fail-Fast: Such iterators throw <code class="docutils literal notranslate"><span class="pre">ConcurrentModificationException</span></code> if there is structural modification of the collection.</p></li>
<li><p>Fail-Safe: Such iterators don’t throw any exceptions if a collection is structurally modified while iterating over it. This is because they operate on the clone of the collection, not on the original collection.</p></li>
</ol>
<p>Fail-Safe iterator may be slower since one have to pay the cost of the clone at the creation of the iterator, even if we only end-up iterating over few elements. Therefore we will rather focus on the Fail-Fast strategy, which corresponds to the most frequent choice in the implementation of Java collections.</p>
<p>To implement a Fail-Fast iterator for our <code class="docutils literal notranslate"><span class="pre">LinkedStack</span></code>, we can keep track of a modification count for the stack.
This count will be incremented whenever there’s a structural modification to the stack (like pushing or popping).
The iterator will then capture this count when it is created and compare its own captured count to the stack’s modification count during iteration.
If they differ, the iterator will throw a <code class="docutils literal notranslate"><span class="pre">ConcurrentModificationException</span></code>.
The <code class="docutils literal notranslate"><span class="pre">LinkedStack</span></code> class has an inner <code class="docutils literal notranslate"><span class="pre">LinkedStackIterator</span></code> class that checks the modification count every time it is asked if there’s a next item or when retrieving the next item.
It is important to understand that <code class="docutils literal notranslate"><span class="pre">LinkedStackIterator</span></code> is an inner class, <em>not</em> a static nested class. An inner class cannot be instantiated without first instantiating the outer class and it is tied to a specific instance of the outer class. This is why, the instance variables of the <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> inner class can be initialized using the instance variables of the outer class.</p>
<p>The sample main method demonstrates that trying to modify the stack during iteration (by pushing a new item) results in a
<code class="docutils literal notranslate"><span class="pre">ConcurrentModificationException</span></code>.</p>
<p>The creation of the iterator has a constant time complexity, <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>. Indeed:</p>
<ol class="arabic simple">
<li><p>The iterator’s current node is set to the top node of the stack. This operation is done in constant time since it is just a reference assignment.</p></li>
<li><p>Modification Count Assignment: The iterator captures the current modification count of the stack. This again is a simple assignment operation, done in constant time.</p></li>
</ol>
<p>No other operations are involved in the iterator’s creation, and notably, there are no loops or recursive calls that would add to the time complexity. Therefore, the total time complexity of creating the LinkedStackIterator is <img class="math" src="_images/math/1c780ff223ec80f15ed09341bdb9396a8bb2a4ed.svg" alt="O(1)"/>.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.Iterator</span><span class="p">;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ConcurrentModificationException</span><span class="p">;</span>

<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LinkedStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Modification count</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>

<span class="w">        </span><span class="n">Node</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">oldTop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">        </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">oldTop</span><span class="p">);</span>
<span class="w">        </span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">modCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&quot;Stack is empty&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">.</span><span class="na">item</span><span class="p">;</span>
<span class="w">        </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="n">modCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isEmpty</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">iterator</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedStackIterator</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LinkedStackIterator</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">expectedModCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modCount</span><span class="p">;</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">hasNext</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">expectedModCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">modCount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentModificationException</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">expectedModCount</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">modCount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentModificationException</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&quot;No more items&quot;</span><span class="p">);</span>

<span class="w">            </span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">item</span><span class="p">;</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedStack</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">stack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">stack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="n">stack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="w">        </span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stack</span><span class="p">.</span><span class="na">iterator</span><span class="p">();</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="na">hasNext</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="na">next</span><span class="p">());</span>
<span class="w">            </span><span class="n">stack</span><span class="p">.</span><span class="na">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will cause ConcurrentModificationException at the next call to hasNext</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/lepl1402.png" alt="Logo"/>
            </a></p>
<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="part1.html">From Python to Java</a></li>
<li class="toctree-l1"><a class="reference internal" href="part2.html">Object-Oriented Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="part3.html">Unit testing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms and Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#time-complexity">Time Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#space-complexity">Space complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algorithm-correctness">Algorithm correctness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abstract-data-types-adt">Abstract Data Types (ADT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">Iterators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="part5.html">Parallel Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="part6.html">Functional Programming</a></li>
</ul>

  <div>
    <h3><a href="index.html">Download the book</a></h3>
    <a href="_static/lepl1402.pdf">PDF version of the book</a>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="part5.html" title="Parallel Programming"
             >next</a> |</li>
        <li class="right" >
          <a href="part3.html" title="Unit testing"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">LEPL1402  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Algorithms and Data Structures</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Sébastien Jodogne, Ramin Sadre, Pierre Schaus.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.2.2.
    </div>
<div class="footer">
    <script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
        var b = c[a];
        if(b.getAttribute("href") && b.hostname !== location.hostname) {
            b.target = "_blank";
            b.rel = "noopener";
        }
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
}
pdf_new_window();
external_new_window();
</script>


  </body>
</html>